use std::fs;
use std::path::Path;
use crate::source_parser::ParseResult;

#[rustfmt::skip]
pub fn generate_docs(parse_result: &ParseResult) -> std::io::Result<()> {
    let base_dir = Path::new("docs/source/pages/scripting");
    fs::create_dir_all(&base_dir)?;

    for (category, funcs) in &parse_result.functions {
        let file_path = base_dir.join("functions").join(format!("{}.rst", category));

        if !file_path.exists() {
            fs::write(&file_path, "")?;
        }
        let content = fs::read_to_string(&file_path)?;
        let mut template = String::new();

        for (_func_key, func) in funcs {
            // detect existing entry by scriptName directive
            let sign = get_func_sign(&func.script_name);
            if !content.contains(&sign) {

                println!("Missing function '{}' in {}.rst, adding stub", func.script_name, category);
                
                template.push_str(&format!(r#"
{sign}

.. csv-table:: **Arguments**
    :header: "Argument", "Type", "Description"
    :align: left

"#              ));
                
                if let Some(params) = &func.params {
                    for p in params {
                        template.push_str(&format!("    \"{}\", \"{}\", \"description\"\n", p.param_name, p.param_type));
                    }
                }

                for r in &func.returns {
                    template.push_str(&format!("\n**Returns** ``{}``\n", r));
                }
                template.push_str("\nthis is the Description of the function. Explain the usage of the function in detail here\n");
                template.push_str(&format!(r#"
**Example**

.. code-block:: cpp

    // stub example for dev.
    // dev. should remove this comment after he is done changing it
    {}(...);

"#, &func.script_name));
                // generate stub
                /*appended.push_str(&format!(".. function:: {}()\n", func.script_name));
                appended.push_str("   :Description: PLACEHOLDER_DESCRIPTION \n");
                appended.push_str("   :Category: \n");
                appended.push_str(category);
                appended.push_str("\n");
                if let Some(params) = &func.params {
                    for p in params {
                        appended.push_str(&format!("   :param {}: {} \n", p.param_name, p.param_type));
                    }
                }
                for r in &func.returns {
                    appended.push_str(&format!("   :returns: {} \n", r));
                }
                appended.push_str("\n");*/
            }
        }

        // Append missing stubs
        if !template.is_empty() {
            let mut file = fs::OpenOptions::new()
                .append(true)
                .open(&file_path)?;
            use std::io::Write;
            writeln!(file, "\n{}", template)?;
        }
    }

    for (category, meths) in &parse_result.methods {
        let file_path = base_dir.join("methods").join(format!("{}.rst", category));

        if !file_path.exists() {
            fs::write(&file_path, "")?;
        }
        let content = fs::read_to_string(&file_path)?;
        let mut template = String::new();

        for (_func_key, meth) in meths {
            // detect existing entry by scriptName directive
            let sign = get_func_sign(&meth.script_name);
            if !content.contains(&sign) {

                println!("Missing method '{}' in {}.rst, adding stub", meth.script_name, category);
                
                template.push_str(&format!(r#"
{sign}

.. csv-table:: **Arguments**
    :header: "Argument", "Type", "Description"
    :align: left

"#              ));

                let mut args = String::new();
                let mut param_names = Vec::new();
                if let Some(params) = &meth.params {
                    for p in &params {
                        template.push_str(&format!("    \"{}\", \"{}\", \"description\"\n", p.param_name, p.param_type));
                        param_names.push(p.param_name.clone());
                    }
                }
                args.push_str(&param_names.join(", "));

                for r in &meth.returns {
                    template.push_str(&format!("\n**Returns** ``{}``\n", r));
                }
                template.push_str("\nthis is the Description of the method. Explain the usage of the method in detail here\n");
                template.push_str(&format!(r#"
**Example**

.. code-block:: cpp

    // stub example for dev.
    // dev. should remove this comment after he is done changing it
    {}({});

"#, &meth.script_name, &args));
            }
        }

        // Append missing stubs
        if !template.is_empty() {
            let mut file = fs::OpenOptions::new()
                .append(true)
                .open(&file_path)?;
            use std::io::Write;
            writeln!(file, "\n{}", template)?;
        }
    }

    Ok(())
}

fn gen_template(funcs: BTreeMap<String, ScriptFunction>, category, is_method: bool) -> std::io::Result<String>
{
    let mut current = "function".to_string();
    if is_method {
        current = "method".to_string();
    }
    for (_func_key, func) in funcs {
        // detect existing entry by scriptName directive
        let sign = get_func_sign(&func.script_name);
        if !content.contains(&sign) {

            println!("Missing {} '{}' in {}.rst, adding stub", &current, &func.script_name, &category);
            
            template.push_str(&format!(r#"
{sign}

.. csv-table:: **Arguments**
    :header: "Argument", "Type", "Description"
    :align: left

"#));

            let mut args = String::new();
            let mut param_names = Vec::new();
            if let Some(params) = &func.params {
                for p in params {
                    template.push_str(&format!("    \"{}\", \"{}\", \"description\"\n", p.param_name, p.param_type));
                }
            }
            args.push_str(&param_names.join(", "));

            for r in &func.returns {
                template.push_str(&format!("\n**Returns** ``{}``\n", r));
            }
            template.push_str(&format!("\nthis is the Description of the {}. Explain the usage in detail here\n", &current));
            template.push_str(&format!(r#"
**Example**

.. code-block:: cpp
    // stub example for dev.
    // dev. should remove this comment after he is done changing it
    
    {}({});

"#, &func.script_name, &args));
        }
    }
}

fn get_func_sign(name: &str) -> String
{
    let num = name.chars().count() as u8;
    let mut dec = String::new();
    for _ in 0..num {
        dec.push('-');
    }

    format!("{}\n{}", name, dec)
}
